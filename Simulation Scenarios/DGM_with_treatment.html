<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Ward B. Eiling">
<meta name="dcterms.date" content="2024-10-31">

<title>DGMs of Qian et al.&nbsp;(2020) - Part 2: With Treatment</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="DGM_with_treatment_files/libs/clipboard/clipboard.min.js"></script>
<script src="DGM_with_treatment_files/libs/quarto-html/quarto.js"></script>
<script src="DGM_with_treatment_files/libs/quarto-html/popper.min.js"></script>
<script src="DGM_with_treatment_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="DGM_with_treatment_files/libs/quarto-html/anchor.min.js"></script>
<link href="DGM_with_treatment_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="DGM_with_treatment_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="DGM_with_treatment_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="DGM_with_treatment_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="DGM_with_treatment_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article toc-left">
<div id="quarto-sidebar-toc-left" class="sidebar toc-left">
  <nav id="TOC" role="doc-toc" class="toc-active" data-toc-expanded="3">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#main-simulation-of-qian-et-al.-2020-with-treatment-and-with-translated-notation" id="toc-main-simulation-of-qian-et-al.-2020-with-treatment-and-with-translated-notation" class="nav-link active" data-scroll-target="#main-simulation-of-qian-et-al.-2020-with-treatment-and-with-translated-notation"><span class="header-section-number">1</span> Main Simulation of Qian et al.&nbsp;(2020): With Treatment and with Translated Notation</a>
  <ul class="collapse">
  <li><a href="#simulations" id="toc-simulations" class="nav-link" data-scroll-target="#simulations"><span class="header-section-number">1.1</span> Simulations</a>
  <ul class="collapse">
  <li><a href="#generative-model-1" id="toc-generative-model-1" class="nav-link" data-scroll-target="#generative-model-1"><span class="header-section-number">1.1.1</span> Generative Model 1</a></li>
  <li><a href="#generative-model-2" id="toc-generative-model-2" class="nav-link" data-scroll-target="#generative-model-2"><span class="header-section-number">1.1.2</span> Generative Model 2</a></li>
  <li><a href="#generative-model-3" id="toc-generative-model-3" class="nav-link" data-scroll-target="#generative-model-3"><span class="header-section-number">1.1.3</span> Generative Model 3</a></li>
  <li><a href="#graphical-representations-of-data-generating-models" id="toc-graphical-representations-of-data-generating-models" class="nav-link" data-scroll-target="#graphical-representations-of-data-generating-models"><span class="header-section-number">1.1.4</span> Graphical representations of Data Generating Models</a></li>
  <li><a href="#data-generating-and-estimation" id="toc-data-generating-and-estimation" class="nav-link" data-scroll-target="#data-generating-and-estimation"><span class="header-section-number">1.1.5</span> Data Generating and Estimation</a></li>
  </ul></li>
  </ul></li>
  <li><a href="#appendix" id="toc-appendix" class="nav-link" data-scroll-target="#appendix"><span class="header-section-number">2</span> Appendix</a>
  <ul class="collapse">
  <li><a href="#original-section-from-qian-et-al.-2020-4.-simulation" id="toc-original-section-from-qian-et-al.-2020-4.-simulation" class="nav-link" data-scroll-target="#original-section-from-qian-et-al.-2020-4.-simulation"><span class="header-section-number">2.1</span> Original Section from Qian et al.&nbsp;(2020): “4. Simulation”</a></li>
  <li><a href="#translation-of-notation" id="toc-translation-of-notation" class="nav-link" data-scroll-target="#translation-of-notation"><span class="header-section-number">2.2</span> Translation of Notation</a></li>
  <li><a href="#explanation-versus-prediction" id="toc-explanation-versus-prediction" class="nav-link" data-scroll-target="#explanation-versus-prediction"><span class="header-section-number">2.3</span> Explanation versus Prediction</a></li>
  <li><a href="#differences-dags-and-path-diagrams" id="toc-differences-dags-and-path-diagrams" class="nav-link" data-scroll-target="#differences-dags-and-path-diagrams"><span class="header-section-number">2.4</span> Differences: DAGs and Path Diagrams</a></li>
  </ul></li>
  </ul>
<div class="quarto-alternate-formats"><h2>Other Formats</h2><ul><li><a href="DGM_with_treatment.pdf"><i class="bi bi-file-pdf"></i>PDF</a></li></ul></div></nav>
</div>
<div id="quarto-margin-sidebar" class="sidebar margin-sidebar zindex-bottom">
</div>
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">DGMs of Qian et al.&nbsp;(2020) - Part 2: With Treatment</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Ward B. Eiling </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">October 31, 2024</p>
    </div>
  </div>
  
    <div>
    <div class="quarto-title-meta-heading">Modified</div>
    <div class="quarto-title-meta-contents">
      <p class="date-modified">November 13, 2024</p>
    </div>
  </div>
    
  </div>
  


</header>


<section id="main-simulation-of-qian-et-al.-2020-with-treatment-and-with-translated-notation" class="level1" data-number="1">
<h1 data-number="1"><span class="header-section-number">1</span> Main Simulation of Qian et al.&nbsp;(2020): With Treatment and with Translated Notation</h1>
<section id="simulations" class="level2" data-number="1.1">
<h2 data-number="1.1" class="anchored" data-anchor-id="simulations"><span class="header-section-number">1.1</span> Simulations</h2>
<p>In the simulation, we considered three generative models (GMs), all of which have an endogenous covariate. In the first two GMs, the endogenous covariate <span class="math inline">\(Z_{ti}\)</span> equals the previous outcome <span class="math inline">\(Y_{ti}\)</span> plus some random noise, so the conditional independence assumption (10) is valid. In GM 3, the endogenous covariate depends directly on <span class="math inline">\(u_{0i}\)</span>, violating assumption (10). The details of the generative models are described below. We follow the notation of Schoot et al.&nbsp;(2017), which is largely based on that of Raudenbusch and Bryk (2002).</p>
<section id="generative-model-1" class="level3" data-number="1.1.1">
<h3 data-number="1.1.1" class="anchored" data-anchor-id="generative-model-1"><span class="header-section-number">1.1.1</span> Generative Model 1</h3>
<p>In GM1, we considered a simple case with only a random intercept and a random slope for <span class="math inline">\(X_{ti}\)</span>, so that <span class="math inline">\(g_0(H_{ti}) = g_1(H_{ti}) = 1\)</span>. <strong>WHAT DOES THIS IMPLY?</strong> The outcome is generated according to the following repeated-observations or within-person model (level 1)</p>
<p><span class="math display">\[
Y_{(t+1)i} = \pi_{0i} + \pi_{1i} Z_{ti} + \pi_{2i} X_{ti} + \pi_{3i} X_{ti} Z_{ti} + e_{(t+1)i}
\]</span></p>
<p>with the person-level or between-person model (level 2)</p>
<p><span class="math display">\[
\pi_{0i} = \beta_{00} + u_{0i} \quad \text{with} \quad u_{0i} \sim \mathcal{N}(0, \sigma^2_{u_0})
\]</span></p>
<p><span class="math display">\[
\pi_{1i} = \beta_{10}
\]</span></p>
<p><span class="math display">\[
\pi_{2i} = \beta_{20} + u_{2i} \quad \text{with} \quad u_{2i} \sim \mathcal{N}(0, \sigma^2_{u_2})
\]</span></p>
<p><span class="math display">\[
\pi_{3i} = \beta_{30}
\]</span></p>
<p>By substitution, we get the single equation model:</p>
<p><span class="math display">\[
Y_{(t+1)i} = \pi_{0i} + \pi_{1i} Z_{ti} + \pi_{2i} X_{ti} + \pi_{3i} X_{ti} Z_{ti} + e_{(t+1)i} \\ = (\beta_{00} + u_{0i}) + \beta_{10} Z_{ti} + X_{ti} (\beta_{20} + u_{2i}) + \beta_{30} X_{ti} Z_{ti} + e_{(t+1)i} \\ = \beta_{00} + \beta_{10} Z_{ti} + u_{0i} + X_{ti} (\beta_{20} + \beta_{30} Z_{ti} + u_{2i}) + e_{(t+1)i}
\]</span></p>
<p>The random effects <span class="math inline">\(u_{0i} \sim N(0, \sigma_{u0}^2)\)</span> and <span class="math inline">\(u_{2i} \sim N(0, \sigma_{u2}^2)\)</span> are independent of each other. The covariate is generated as <span class="math inline">\(Z_{i1} \sim N(0, 1)\)</span>, and for <span class="math inline">\(t \geq 2\)</span>,</p>
<p><span class="math display">\[
Z_{ti} = Y_{ti} + N(0, 1).
\]</span></p>
<p>The randomization probability <span class="math inline">\(p_t\)</span> is constant at <span class="math inline">\(1/2\)</span>. Thus, <span class="math inline">\(X_{ti} \sim \text{Bernoulli}(0.5) \quad \text{for} \quad i = 1, \ldots, N \quad \text{and} \quad t = 1, \ldots, T\)</span>. In other words, each individual has an independent 50% chance of receiving the treatment at each time point. The exogenous noise is <span class="math inline">\(e_{(t+1)i} \sim N(0, \sigma_e^2)\)</span>.</p>
</section>
<section id="generative-model-2" class="level3" data-number="1.1.2">
<h3 data-number="1.1.2" class="anchored" data-anchor-id="generative-model-2"><span class="header-section-number">1.1.2</span> Generative Model 2</h3>
<p>In GM2, we considered the case where <span class="math inline">\(g_0(H_{ti}) = g_1(H_{ti}) = (1, Z_{ti})\)</span>, <strong>which implies that the random effects <span class="math inline">\(u_{0i}\)</span> and <span class="math inline">\(u_{1i}\)</span> are modeled as depending only on a baseline level and the current covariate <span class="math inline">\(Z_{ti}\)</span>. CHECK IF THIS IS TRUE</strong>. In addition, the randomization probability is time-varying. The outcome is generated according to the same repeated-observations model presented in GM1. However, the person-level model is different:</p>
<p><span class="math display">\[
\pi_{0i} = \beta_{00} + u_{0i} \quad \text{with} \quad u_{0i} \sim \mathcal{N}(0, \sigma^2_{u_0})
\]</span></p>
<p><span class="math display">\[
\pi_{1i} = \beta_{10} + u_{1i} \quad \text{with} \quad u_{1i} \sim \mathcal{N}(0, \sigma^2_{u_1})
\]</span></p>
<p><span class="math display">\[
\pi_{2i} = \beta_{20} + u_{2i} \quad \text{with} \quad u_{2i} \sim \mathcal{N}(0, \sigma^2_{u_2})
\]</span></p>
<p><span class="math display">\[
\pi_{3i} = \beta_{30} + u_{3i} \quad \text{with} \quad u_{3i} \sim \mathcal{N}(0, \sigma^2_{u_3})
\]</span></p>
<p>By substitution, we get the single equation model:</p>
<p><span class="math display">\[
Y_{(t+1)i} = \beta_{00} + \beta_{10} Z_{ti} + u_{0i} + u_{1i} Z_{ti} + X_{ti} \left( \beta_{20} + \beta_{30} Z_{ti} + u_{2i} + u_{3i} Z_{ti} \right) + e_{(t+1)i}.
\]</span></p>
<p>The random effects <span class="math inline">\(u_{ji} \sim N(0, \sigma_{u_j}^2)\)</span>, for <span class="math inline">\(0 \leq j \leq 3\)</span>, are independent of each other. The covariate is generated as <span class="math inline">\(Z_{i1} \sim N(0, 1)\)</span>, and for <span class="math inline">\(t \geq 2\)</span>,</p>
<p><span class="math display">\[
Z_{ti} = Y_{ti} + N(0, 1).
\]</span></p>
<p>The randomization probability depends on <span class="math inline">\(Z_{ti}\)</span>:</p>
<p><span class="math display">\[
p_t = P(X_{ti} = 1 \mid H_{it}) = 0.7 \cdot IF(Z_{ti} &gt; -1.27) + 0.3 \cdot IF(Z_{ti} \leq -1.27),
\]</span></p>
<p>where <span class="math inline">\(IF(\cdot)\)</span> represents the indicator function, and the cutoff <span class="math inline">\(-1.27\)</span> was chosen so that <span class="math inline">\(p_t = P(X_{ti} = 1 \mid H_{it})\)</span> equals 0.7 or 0.3 for about half of the time. In other words, if the value for the covariate for any given person and timepoint is above the cutoff, the probability of receiving the treatment <span class="math inline">\(p_t\)</span> is 0.7; otherwise, it is 0.3. Accordingly, <span class="math inline">\(X_{ti} \sim \text{Bernoulli}(p_t)\)</span> for <span class="math inline">\(i = 1, \ldots, N\)</span> and <span class="math inline">\(t = 1, \ldots, T\)</span>. The exogenous noise is <span class="math inline">\(e_{(t+1)i} \sim N(0, \sigma_e^2)\)</span>.</p>
</section>
<section id="generative-model-3" class="level3" data-number="1.1.3">
<h3 data-number="1.1.3" class="anchored" data-anchor-id="generative-model-3"><span class="header-section-number">1.1.3</span> Generative Model 3</h3>
<p>GM3 is the same as GM1, except that the covariate <span class="math inline">\(Z_{ti}\)</span> depends directly on <span class="math inline">\(u_{0i}\)</span>:</p>
<p><span class="math display">\[
Z_{i1} \sim N(u_{0i}, 1), \quad Z_{ti} = Y_{ti} + N(u_{0i}, 1) \text{ for } t \geq 2.
\]</span></p>
<p>We chose the following parameter values:</p>
<p><span class="math display">\[
\beta_{00} = -2, \quad \beta_{10} = -0.3, \quad \beta_{20} = 1, \quad \beta_{30} = 0.3,
\]</span></p>
<p><span class="math display">\[
\sigma_{u0}^2 = 4, \quad \sigma_{u1}^2 = \frac{1}{4}, \quad \sigma_{u2}^2 = 1, \quad \sigma_{u3}^2 = \frac{1}{4}, \quad \sigma_e^2 = 1.
\]</span></p>
</section>
<section id="graphical-representations-of-data-generating-models" class="level3" data-number="1.1.4">
<h3 data-number="1.1.4" class="anchored" data-anchor-id="graphical-representations-of-data-generating-models"><span class="header-section-number">1.1.4</span> Graphical representations of Data Generating Models</h3>
<p>So the DAG for the first couple observations of GM1 looks like</p>
<div id="fig-DAGs" class="quarto-layout-panel">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-DAGs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;1: Directed Acylcic Graphs (DAGs) for the three Generative Models
</figcaption>
<div aria-describedby="fig-DAGs-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<div class="quarto-layout-row">
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-DAGs" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-GM1_DAG" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-fig" id="fig-GM1_DAG-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(a) Generative Model 1
</figcaption>
<div aria-describedby="fig-GM1_DAG-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figure/GM1_DAG_cropped.png" class="img-fluid figure-img" data-ref-parent="fig-DAGs">
</div>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-DAGs" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-GM2_DAG" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-fig" id="fig-GM2_DAG-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(b) Generative Model 2
</figcaption>
<div aria-describedby="fig-GM2_DAG-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figure/GM1_DAG_cropped.png" class="img-fluid figure-img" data-ref-parent="fig-DAGs">
</div>
</figure>
</div>
</div>
<div class="quarto-layout-cell-subref quarto-layout-cell" data-ref-parent="fig-DAGs" style="flex-basis: 33.3%;justify-content: flex-start;">
<div id="fig-GM3_DAG" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-subfloat-fig figure">
<figcaption class="quarto-float-caption-top quarto-subfloat-caption quarto-subfloat-fig" id="fig-GM3_DAG-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
(c) Generative Model 3
</figcaption>
<div aria-describedby="fig-GM3_DAG-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="figure/GM3_DAG_cropped.png" class="img-fluid figure-img" data-ref-parent="fig-DAGs">
</div>
</figure>
</div>
</div>
</div>
</div>
</figure>
</div>
<p>The red arrows here show the biased paths after controlling for the covariate <span class="math inline">\(Z_{it}\)</span>.</p>
<p>Or we can display it as a path diagram, where parameter values are displayed and moderation is shown by the dashed arrow.</p>
<div class="cell">
<div class="cell-output-display">
<div id="fig-GM1_path" class="quarto-float quarto-figure quarto-figure-center anchored">
<figure class="quarto-float quarto-float-fig figure">
<figcaption class="quarto-float-caption-top quarto-float-caption quarto-float-fig" id="fig-GM1_path-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
Figure&nbsp;2: Path diagram for Generative Model 1
</figcaption>
<div aria-describedby="fig-GM1_path-caption-0ceaefa1-69ba-4598-a22c-09a6ac19f8ca">
<img src="DGM_with_treatment_files/figure-html/fig-GM1_path-1.png" class="img-fluid figure-img" width="672">
</div>
</figure>
</div>
</div>
</div>
<!-- ![Path diagram for Generative Model 1](fig-GM1_path-1.png) -->
<p>We can make a couple observations from this path diagram:</p>
<ul>
<li>Contrary to the DAG, this path diagram shows the moderation effect (1) of <span class="math inline">\(Z_{it}\)</span> on the relationship between <span class="math inline">\(X_{it}\)</span> and <span class="math inline">\(Y_{ti+1}\)</span> and (2) of <span class="math inline">\(u_{2i}\)</span> on the relationship between <span class="math inline">\(Z_{ti}\)</span> and <span class="math inline">\(Y_{(t+1)}\)</span>.</li>
<li>Similar to the example without treatment in section 2.2, the covariate <span class="math inline">\(Z_{it}\)</span> is determined by the previous value of the outcome <span class="math inline">\(Y_{it}\)</span>—which makes it an endogenous time-varying covariate.</li>
</ul>
</section>
<section id="data-generating-and-estimation" class="level3" data-number="1.1.5">
<h3 data-number="1.1.5" class="anchored" data-anchor-id="data-generating-and-estimation"><span class="header-section-number">1.1.5</span> Data Generating and Estimation</h3>
<p>The data generating process for this model is given by</p>
<p><span class="math display">\[
Y_{(t+1)i} = (\beta_{00} + u_{0i}) + \beta_{10} Z_{ti} + X_{ti} (\beta_{20} + u_{2i}) + \beta_{30} X_{ti} Z_{ti} + e_{(t+1)i}
\]</span></p>
<!-- ```{r} -->
<!-- #| label: GM1_datageneration -->
<!-- #| echo: true -->
<!-- #| eval: false -->
<!-- #| cache: true -->
<!-- dgm1 <- function(sample_size, total_T) { -->
<!--     # Parameters -->
<!--     gamma_00 <- -2   # Fixed intercept -->
<!--     beta_2 <- -0.3 # Fixed slope for Z -->
<!--     gamma_10 <- 0.5    # Fixed effect of treatment (X) -->
<!--     beta_3 <- 0.3  # Interaction effect between treatment (X) and covariate (Z) -->
<!--     sigma_u0 <- 2    # SD of random intercept (u_0i) -->
<!--     sigma_u2 <- 1    # SD of random slope for treatment (u_1i) -->
<!--     sigma_e <- 1     # SD of error term (e_{it+1}) -->
<!--     prob_x <- 0.5    # Randomization probability for treatment (X) -->
<!--     # Data frame setup -->
<!--     df_names <- c("userid", "day", "Z", "prob_X", "X", "Y", "u0", "u2", "e", "delta") -->
<!--     dta <- data.frame(matrix(NA, nrow = sample_size * total_T, ncol = length(df_names))) -->
<!--     names(dta) <- df_names -->
<!--     # Assign userid and day -->
<!--     dta$userid <- rep(1:sample_size, each = total_T) -->
<!--     dta$day <- rep(1:total_T, times = sample_size) -->
<!--     # Generate uncorrelated random effects -->
<!--     u_0i <- rnorm(sample_size, mean = 0, sd = sigma_u0) -->
<!--     u_1i <- rnorm(sample_size, mean = 0, sd = sigma_u2) -->
<!--     # Data generation for each time point -->
<!--     for (t in 1:total_T) { -->
<!--         # Row index for day t for every subject -->
<!--         row_index <- seq(from = t, by = total_T, length = sample_size) -->
<!--         # Generate Z based on the process described -->
<!--         if (t == 1) { -->
<!--             dta$Z[row_index] <- rnorm(sample_size, mean = 0, sd = 1) -->
<!--         } else { -->
<!--             dta$Z[row_index] <- dta$Y[row_index_lag1] + rnorm(sample_size, mean = 0, sd = 1) -->
<!--         } -->
<!--         # Set fixed probability for treatment assignment -->
<!--         dta$prob_X[row_index] <- rep(prob_x, sample_size) -->
<!--         # Treatment assignment -->
<!--         dta$X[row_index] <- rbinom(sample_size, 1, dta$prob_X[row_index]) -->
<!--         # Error term -->
<!--         dta$e[row_index] <- rnorm(sample_size, mean = 0, sd = sigma_e) -->
<!--         # compute part of the equation -->
<!--         dta$delta[row_index] <- gamma_10 + beta_3 * dta$Z[row_index] + u_1i -->
<!--         # Outcome Y -->
<!--         dta$Y[row_index] <- gamma_00 + beta_2 * dta$Z[row_index] + u_0i +  -->
<!--                             dta$X[row_index] * dta$delta[row_index] + dta$e[row_index] -->
<!--         # Store random effects -->
<!--         dta$u0[row_index] <- u_0i -->
<!--         dta$u2[row_index] <- u_1i -->
<!--         # Update row index for lagged Y -->
<!--         row_index_lag1 <- row_index -->
<!--     } -->
<!--     return(dta) -->
<!-- } -->
<!-- # Run the data generation function -->
<!-- set.seed(123987) -->
<!-- data <- dgm1(sample_size = 100000, total_T = 10) -->
<!-- saveRDS(data, "Simulation Scenarios/data/Qian_GM1_data.rds") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #| label: GM1_datageneration_qian -->
<!-- # source("Scripts/Qian2020 Code/generative_model.R") -->
<!-- # source("Scripts/DataGeneratingModels/GM1.R") -->
<!-- #  -->
<!-- # # Run the data generation function -->
<!-- # set.seed(123987) -->
<!-- # data <- dgm1(sample_size = 100000, total_T = 10) -->
<!-- # data2 <- dgm_with_treatment(sample_size = 100000, total_T = 10, dgm_type = 1) -->
<!-- # data3 <- GM1(sample_size = 100000, total_T = 10) -->
<!-- #  -->
<!-- # fit <- lmer(Y ~ Z * X + (1 + X | userid), data = data) -->
<!-- # fit2 <- lmer(Y ~ X * A + (1 + A | userid), data = data2) -->
<!-- # fit3 <- lmer(Y ~ X * A + (1 + A | userid), data = data3) -->
<!-- #  -->
<!-- # fixef(fit) -->
<!-- # fixef(fit2) -->
<!-- # fixef(fit3) -->
<!-- ``` -->
<!-- The analytical model for the mixed linear model is equivalent to the data generating model: -->
<!-- $$ -->
<!-- Y_{(t+1)i} = (\beta_{00} + u_{0i}) + \beta_{10} Z_{ti} + X_{ti} (\beta_{20} + u_{2i}) + \beta_{30} X_{ti} Z_{ti} + e_{(t+1)i} -->
<!-- $$ -->
<!-- However, for GEE, the analytical model does not include random coefficients, so reduces to: -->
<!-- $$ -->
<!-- Y_{(t+1)i} = \beta_{00} + \beta_{10} Z_{ti} + X_{ti} \beta_{20} + \beta_{30} X_{ti} Z_{ti} + e_{(t+1)i} -->
<!-- $$ -->
<!-- Considering this difference and the nonzero specification of the random effects, we expect that the fixed treatment effect, denoted by $gamma_10$, is not equal across the mixed linear model and its GEE counterparts. -->
<!-- ```{r} -->
<!-- #| label: GM1_fit -->
<!-- #| cache: false -->
<!-- #| echo: true -->
<!-- #| eval: false -->
<!-- # load data -->
<!-- data <- readRDS("Simulation Scenarios/data/Qian_GM1_data.rds") -->
<!-- # Fit models -->
<!-- gee_indep <- geeglm(Y ~ Z + X + Z*X, id = userid, data = data, corstr = "independence") -->
<!-- gee_exch <- geeglm(Y ~ Z + X + Z*X, id = userid, data = data, corstr = "exchangeable") -->
<!-- gee_ar1 <- geeglm(Y ~ Z + X + Z*X, id = userid, data = data, corstr = "ar1") -->
<!-- mlm_mle <- lmer(Y ~ Z + X + Z*X + (1 + X | userid), data = data, REML = FALSE) -->
<!-- treatment_effect <- c(coef(gee_indep)["X"], coef(gee_exch)["X"], coef(gee_ar1)["X"], fixef(mlm_mle)["X"]) -->
<!-- true_treatment_effect <- gamma_10 <- 1 -->
<!-- interaction_effect <- c(coef(gee_indep)["Z:X"], coef(gee_exch)["Z:X"], coef(gee_ar1)["Z:X"], fixef(mlm_mle)["Z:X"]) -->
<!-- true_interaction_effect <- beta_3 <- 0.3 -->
<!-- df_results <- data.frame(row.names = c("GEE (Indep)", "GEE (Exch)", "GEE (AR1)", "MLM (MLE)"), treatment_estimate = treatment_effect, treatment_true = gamma_10, interaction_estimate = interaction_effect, interaction_true = true_interaction_effect) -->
<!-- saveRDS(df_results, "Simulation Scenarios/data/Qian_GM1_results.rds") -->
<!-- ``` -->
<!-- ```{r} -->
<!-- #| label: GM1_results -->
<!-- #| echo: false -->
<!-- # df_results <- readRDS("Simulation Scenarios/data/Qian_GM1_results.rds") -->
<!-- # knitr::kable(df_results, digits = 3, caption = "Generating Model 1 - Treatment Effect Estimates") -->
<!-- ``` -->
</section>
</section>
</section>
<section id="appendix" class="level1" data-number="2">
<h1 data-number="2"><span class="header-section-number">2</span> Appendix</h1>
<section id="original-section-from-qian-et-al.-2020-4.-simulation" class="level2" data-number="2.1">
<h2 data-number="2.1" class="anchored" data-anchor-id="original-section-from-qian-et-al.-2020-4.-simulation"><span class="header-section-number">2.1</span> Original Section from Qian et al.&nbsp;(2020): “4. Simulation”</h2>
<p>In the simulation, we considered three generative models (GMs), all of which have an endogenous covariate. In the first two GMs, the endogenous covariate <span class="math inline">\(X_{it}\)</span> equals the previous outcome <span class="math inline">\(Y_{it}\)</span> plus some random noise, so the conditional independence assumption (10) is valid. In GM 3, the endogenous covariate depends directly on <span class="math inline">\(b_i\)</span>, violating assumption (10). The details of the generative models are described below.</p>
<p>In GM1, we considered a simple case with only a random intercept and a random slope for <span class="math inline">\(A_{it}\)</span>, so that <span class="math inline">\(Z_{i(t_0)} = Z_{i(t_2)} = 1\)</span> in model (7). The outcome is generated as:</p>
<p><span class="math display">\[
Y_{it+1} = \alpha_0 + \alpha_1 X_{it} + b_{i0} + A_{it} (\beta_0 + \beta_1 X_{it} + b_{i2}) + \epsilon_{it+1}.
\]</span></p>
<p>The random effects <span class="math inline">\(b_{i0} \sim N(0, \sigma_{b0}^2)\)</span> and <span class="math inline">\(b_{i2} \sim N(0, \sigma_{b2}^2)\)</span> are independent of each other. The covariate is generated as <span class="math inline">\(X_{i1} \sim N(0, 1)\)</span>, and for <span class="math inline">\(t \geq 2\)</span>,</p>
<p><span class="math display">\[
X_{it} = Y_{it} + N(0, 1).
\]</span></p>
<p>The randomization probability <span class="math inline">\(p_t\)</span> is constant at <span class="math inline">\(1/2\)</span>. The exogenous noise is <span class="math inline">\(\epsilon_{it+1} \sim N(0, \sigma_\epsilon^2)\)</span>.</p>
<p>In GM2, we considered the case where <span class="math inline">\(Z_{i(t_0)} = Z_{i(t_2)} = 1\)</span>, with time-varying randomization probability. The outcome is generated as:</p>
<p><span class="math display">\[
Y_{it+1} = \alpha_0 + \alpha_1 X_{it} + b_{i0} + b_{i1} X_{it} + A_{it} (\beta_0 + \beta_1 X_{it} + b_{i2} + b_{i3} X_{it}) + \epsilon_{it+1}.
\]</span></p>
<p>The random effects <span class="math inline">\(b_{ij} \sim N(0, \sigma_{b_j}^2)\)</span>, for <span class="math inline">\(0 \leq j \leq 3\)</span>, are independent of each other. The covariate is generated as <span class="math inline">\(X_{i1} \sim N(0, 1)\)</span>, and for <span class="math inline">\(t \geq 2\)</span>,</p>
<p><span class="math display">\[
X_{it} = Y_{it} + N(0, 1).
\]</span></p>
<p>The randomization probability depends on <span class="math inline">\(X_{it}\)</span>:</p>
<p><span class="math display">\[
p_t = 0.7 \cdot 1(X_{it} &gt; -1.27) + 0.3 \cdot 1(X_{it} \leq -1.27),
\]</span></p>
<p>where <span class="math inline">\(1(\cdot)\)</span> represents the indicator function, and the cutoff <span class="math inline">\(-1.27\)</span> was chosen so that <span class="math inline">\(p_t\)</span> equals 0.7 or 0.3 for about half of the time. The exogenous noise is <span class="math inline">\(\epsilon_{it+1} \sim N(0, \sigma_\epsilon^2)\)</span>.</p>
<p>GM3 is the same as GM 1, except that the covariate <span class="math inline">\(X_{it}\)</span> depends directly on <span class="math inline">\(b_i\)</span>:</p>
<p><span class="math display">\[
X_{i1} \sim N(b_{i0}, 1), \quad X_{it} = Y_{it} + N(b_{i0}, 1) \text{ for } t \geq 2.
\]</span></p>
<p>We chose the following parameter values:</p>
<p><span class="math display">\[
\alpha_0 = -2, \quad \alpha_1 = -0.3, \quad \beta_0 = 1, \quad \beta_1 = 0.3,
\]</span></p>
<p><span class="math display">\[
\sigma_{b0}^2 = 4, \quad \sigma_{b1}^2 = \frac{1}{4}, \quad \sigma_{b2}^2 = 1, \quad \sigma_{b3}^2 = \frac{1}{4}, \quad \sigma_\epsilon^2 = 1.
\]</span></p>
</section>
<section id="translation-of-notation" class="level2" data-number="2.2">
<h2 data-number="2.2" class="anchored" data-anchor-id="translation-of-notation"><span class="header-section-number">2.2</span> Translation of Notation</h2>
<p>In the table below, we will provide the translation of original notation in Qian et al.&nbsp;(2020) to the notation by Schoot et al.&nbsp;(2017). This notation in turn, is very similar to and likely based on the notation by Raudenbush and Bryk (2002). However, rather than representing the random effects with an <span class="math inline">\(r\)</span>, the notation by Schoot et al.&nbsp;(2017) uses <span class="math inline">\(u\)</span>.</p>
<table class="caption-top table">
<colgroup>
<col style="width: 38%">
<col style="width: 30%">
<col style="width: 30%">
</colgroup>
<thead>
<tr class="header">
<th>Parameter/variable</th>
<th>Qian et al.&nbsp;(2020)</th>
<th>Schoot et al.&nbsp;(2017)</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Covariate</td>
<td><span class="math inline">\(X_{it}\)</span></td>
<td><span class="math inline">\(Z_{ti}\)</span></td>
</tr>
<tr class="even">
<td>Randomized Treatment</td>
<td><span class="math inline">\(A_{it}\)</span></td>
<td><span class="math inline">\(X_{ti}\)</span></td>
</tr>
<tr class="odd">
<td>Outcome</td>
<td><span class="math inline">\(Y_{it+1}\)</span></td>
<td><span class="math inline">\(Y_{(t+1)i}\)</span></td>
</tr>
<tr class="even">
<td>Fixed intercept</td>
<td><span class="math inline">\(\alpha_0\)</span></td>
<td><span class="math inline">\(\beta_{00}\)</span></td>
</tr>
<tr class="odd">
<td>Random intercept</td>
<td><span class="math inline">\(b_{i0}\)</span></td>
<td><span class="math inline">\(u_{0i}\)</span></td>
</tr>
<tr class="even">
<td>Fixed slope for covariate</td>
<td><span class="math inline">\(\alpha_1\)</span></td>
<td><span class="math inline">\(\beta_{10}\)</span></td>
</tr>
<tr class="odd">
<td>Random slope for covariate</td>
<td><span class="math inline">\(b_{i1}\)</span></td>
<td><span class="math inline">\(u_{1i}\)</span></td>
</tr>
<tr class="even">
<td>Fixed slope of treatment</td>
<td><span class="math inline">\(\beta_0\)</span></td>
<td><span class="math inline">\(\beta_{20}\)</span></td>
</tr>
<tr class="odd">
<td>Random slope for treatment</td>
<td><span class="math inline">\(b_{i2}\)</span></td>
<td><span class="math inline">\(u_{2i}\)</span></td>
</tr>
<tr class="even">
<td>fixed interaction effect of covariate and treatment</td>
<td><span class="math inline">\(\beta_1\)</span></td>
<td><span class="math inline">\(\beta_{30}\)</span></td>
</tr>
<tr class="odd">
<td>Random interaction effect of covariate and treatment</td>
<td><span class="math inline">\(b_{i3}\)</span></td>
<td><span class="math inline">\(u_{3i}\)</span></td>
</tr>
<tr class="even">
<td>Error term (exogenous noise)</td>
<td><span class="math inline">\(\epsilon_{it+1}\)</span></td>
<td><span class="math inline">\(e_{(t+1)i}\)</span></td>
</tr>
<tr class="odd">
<td>Randomization probability</td>
<td><span class="math inline">\(p_t\)</span></td>
<td><span class="math inline">\(p_t\)</span></td>
</tr>
<tr class="even">
<td>Residual variance</td>
<td><span class="math inline">\(\sigma^2_{\epsilon}\)</span></td>
<td><span class="math inline">\(\sigma^2_{e}\)</span></td>
</tr>
<tr class="odd">
<td>Random intercept variance</td>
<td><span class="math inline">\(\sigma^2_{b0}\)</span></td>
<td><span class="math inline">\(\sigma^2_{u0}\)</span></td>
</tr>
<tr class="even">
<td>random slope variance for covariate</td>
<td><span class="math inline">\(\sigma^2_{b1}\)</span></td>
<td><span class="math inline">\(\sigma^2_{u1}\)</span></td>
</tr>
<tr class="odd">
<td>Random slope variance for treatment</td>
<td><span class="math inline">\(\sigma^2_{b2}\)</span></td>
<td><span class="math inline">\(\sigma^2_{u2}\)</span></td>
</tr>
<tr class="even">
<td>Random slope variance for interaction</td>
<td><span class="math inline">\(\sigma^2_{b3}\)</span></td>
<td><span class="math inline">\(\sigma^2_{u3}\)</span></td>
</tr>
</tbody>
</table>
</section>
<section id="explanation-versus-prediction" class="level2" data-number="2.3">
<h2 data-number="2.3" class="anchored" data-anchor-id="explanation-versus-prediction"><span class="header-section-number">2.3</span> Explanation versus Prediction</h2>
<p>In het voorbeeld van Diggle et al.&nbsp;(2002) wat we vorige week hebben besproken, werd vermeld dat een cross-sectionele relatie tussen <span class="math inline">\(X_{it}\)</span> en <span class="math inline">\(Y_{it}\)</span> van interesse kan zijn met longitudinale data als voorspellen het doel is:</p>
<blockquote class="blockquote">
<p>“In many applications the cross-sectional association between Xit and Yit is of substantive interest. For example, in assessing the predictive potential of biomarkers for the detection of cancer, the accuracy of a marker is typically characterized by the cross-sectional sensitivity and specificity. Although alternative predictive models may be developed using longitudinal marker series, these models would not apply to the common clinical setting where only a single measurement is available.” (Diggle et al., 2002, p.&nbsp;256)</p>
</blockquote>
<p>Daarentegen legt Qian et al.&nbsp;(2020) juist de nadruk op de voordelen van mixed linear models om tegelijkertijd ook individuele verschillen te kunnen voorspellen, waarbij de focus meer ligt op causaliteit:</p>
<blockquote class="blockquote">
<p>“A particularly appealing feature of random effects models is the ability to predict person-specific random effects, which enables quantitative characterization of between person heterogeneity due to unobserved factors (Schwartz and Stone, 2007, Bolger and Laurenceau, 2013). Understanding such heterogeneity can bring forth new scientific hypotheses for further studies. In addition, the random effects provide a model for the within-person dependence in the time-varying outcome, which improves efficiency in parameter estimation.” (Qian et al., 2020, p.&nbsp;376)</p>
</blockquote>
</section>
<section id="differences-dags-and-path-diagrams" class="level2" data-number="2.4">
<h2 data-number="2.4" class="anchored" data-anchor-id="differences-dags-and-path-diagrams"><span class="header-section-number">2.4</span> Differences: DAGs and Path Diagrams</h2>
<p>As mentioned by Ellen in the last meeting (17-10):</p>
<blockquote class="blockquote">
<p>“Conventional DAGs do not only represent main effects but rather the combination of main effects and interactions. Once you have drawn your DAG, you already assume that any variables pointing to the same outcome can modify the effect of the others pointing to the same outcome.” (<a href="https://stats.stackexchange.com/questions/157775/representing-interaction-effects-in-directed-acyclic-graphs">stackexchange</a>)</p>
</blockquote>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>